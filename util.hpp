#pragma once
#include <vector>
#include <string>
#include <cstdint>
#include <cstdio>
#include <cerrno>
#include <cstdlib>
#include "hashmap.hpp"

using namespace std;

const size_t k_max_msg = 32 << 20; // 32MB
const size_t k_max_args = 200 * 1000;

struct Conn
{
    int fd = -1;
    // application's intention, for the event loop
    bool want_read = false;
    bool want_write = false;
    bool want_close = false;
    // buffered input and output
    vector<uint8_t> incoming; // data to be parsed by the application
    vector<uint8_t> outgoing; // responses generated by the application
};

struct Response
{
    uint32_t status = 0;
    vector<uint8_t> payload; // indicates the message content
};

struct Entry
{
    string key;
    string val;
    HashNode node; // intrusive ds -> meant to be embedded not referenced.
};

enum
{
    RES_OK = 0,
    RES_ERR = 1, // error
    RES_NX = 2,  // key not found
};

// error code for TAG_ERR
enum {
    ERR_UNKNOWN = 1,    // unknown command
    ERR_TOO_BIG = 2,    // response too big
};

/*
Serialization (binary, little-endian):

Primitive box format:
[TAG][4B payload_len][payload bytes]

Types:
- NIL:
  [TAG]

- INT:
  [TAG][4B len=8][8B int64]

- DOUBLE:
  [TAG][4B len=8][8B double]

- STRING:
  [TAG][4B len][len bytes]

- ARRAY:
  [TAG][4B count][elements...]

- ERROR:
  [TAG][4B code][4B msg_len][msg bytes]

Message framing:
[4B total_payload_size][serialized data]
*/

enum
{
    TAG_NIL = 0, // nil
    TAG_ERR = 1, // error code + msg
    TAG_STR = 2, // string
    TAG_INT = 3, // int64
    TAG_DBL = 4, // double
    TAG_ARR = 5, // array
};

#define container_of(ptr, T, member) \
    ((T *)((char *)ptr - offsetof(T, member)))

void die(const char *msg)
{
    int err = errno;
    fprintf(stderr, "[%d] %s\n", err, msg);
    abort();
}
static void msg(const char *msg)
{
    fprintf(stderr, "%s\n", msg);
}
